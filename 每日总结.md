# 每日总结

## 算法归纳

**双指针**：弗洛伊德的乌龟和兔子  --==**快慢针**==

![image-20200520232412724](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200520232412724.png)

- - 🐰🐢

- 假设入环之前的长度为L, 入环之后快慢指针第一相遇时快指针比慢指针🐢多跑了N圈, 每一圈的长度为C, 此时快指针🐰在环内离入环节点的距离为M
- 此时慢指针🐢走过的距离为: `L + M`
- 此时快指针🐰走过的距离为: `L + M + N * C`
- 因为快指针🐰的速度是慢指针🐢的两倍, 所以有: `2 * (L +M) = L + M + N * C`
- 整理后得到: `(N - 1) * C + (C - M) = L`，也就是`C - M = L`
- 由此可知, 若此时有两个慢指针🐢同时分别从链表头结点和快慢指针第一次相遇的节点出发, 两者必然会在入环节点相遇

## 2020年

### 5月

#### 14日

牛客网：30题 ，17正确



LeetCode算法：

- 142：环形链表II
  - 跟上个的想法一摸一样，还是用Set，然后返回环形回来对应的节点。
- 167：两数之和II
  - 输入一个升序数组，一个目标值，从数组中找到两数相加能等于目标值，返回下标。  使用双指针非常快速完成。



原则：

- 里氏替换原则：--
  - 尽量少覆写父类方法。
  - 通用做法：让原来的父类和子类都继承一个更加通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。
- 开闭原则：
  - 类对扩展开放，对修改关闭。
- 迪米特法则：又称为最少知道原则。
  - 对于被以来的类不管多么复杂，都尽量将逻辑封装在类的内部。
  - 对外除了提供了public方法，不对外泄露任何信息。与直接朋友通信。
  - 直接朋友为成员变量、方法参数类型、方法返回值 中的类 为直接朋友。核心主要是降低类之间的耦合。



《码出高效》：114-124

- 走进JVM：

  - 字节码：字节码主要指令。

    1. 加载或存储指令。
    2. 运行指令
    3. 类型转换指令
    4. 对象创建与访问指令
    5. 操作栈管理指令
    6. 方法调用与返回指令
    7. 同步指令

    我们编写好的.java源代码文件，在编译成字节码前还通过 词法解析、语法解析、语义分析。

    字节码必须通过类加载过程加载在JVM环境后，才可以执行。

    执行有三种模式：

    1. 解释执行

    2. JIT编译执行

    3. JIT编译与解释混合执行（主流JVM默认执行模式）

       其优势在于，解释器在启动后先解释执行，省去编译时间。随着时间推进，JVM通过热点代码统计分析，识别高频的方法调用、循环体、公共模块等。再由JIT动态编译技术，将热点代码转换成机器码，直接交给CPU执行。

       

  - 类加载过程：

    任何程序都需要加载到内存才能与CPU进行交流。字节码同样需要加载到内存中，才可以实例类。加载类是，使用Parents Delegation Model，以为双亲委派模型。Java的类加载器是一个运行时核心基础设施模块，主要是在运行之初类的Load、Link和Init，即加载、链接、初始化。类加载是一个将.class字节码文件实例化成Class对象并进行相关初始化的过程。全小写的class是关键字，用来定义类，而首字母大写的Class，他是所有class的类。任何小写的class定义的类，都有一个属性：class，来获取此类的大写Class类对象。通过Class对象的属性 .getDeclaredField反射获取私有成员变量、方法。P120回顾。

    

    类加载器是图和定位到具体的类文件？

    - 类加载器类似于原始部结构，存在权力等级制度。最高一层的类加载器Bootstrap是通过C/C++实现的，并不存在JVM体系内，所以输出为null。低层次的当前类加载器，不能覆盖更高层次类加载器已经加载的类。

    - 如果低层次的类加载器像加载一个未知类，要非常有礼貌的向上级询问：

      - 请问，这个类已经只加载了吗？

        被询问的高层次类加载器会自问两个问题：

        1. 我是否已加载过此类？如果两问题都是否，才能让当前类加载。

        2. 如果没有，是否可以加载此类？

        如果所有上级的答案都为否的话，那么当前了就可一加载此对象。

        



#### 16日



#### 17日

牛客网：刷题30，正确22。



LeetCode算法：

- 234题：判断链表是否是会为回文链表

  - 解法一：将链表转成数组ArrayList，再通过双指针进行判断

    ```java
    List<Integer> res = new ArrayList<>();
    res.get(start).equals(res.get(end)) // 进行判断
    ```

    但是这个方法效率太慢。

  - 解法二：先用快慢指针定位到链表中位，然后将后部分都倒转过来，在进行双指针的对比

    ```java
     ListNode next = mid.next;
     mid.next = pre;
     pre = mid;
     mid = next;
    ```

- 283题：移动零

  - 解法：双遍历，第一次遍历非0数往前移，且记录非0个数

    ```java
    int j = 0;
    for(int i=0;i<nums.length;++i) {
    			if(nums[i]!=0) {
    				nums[j++] = nums[i];
    			}
    ```

    ​			第二次遍历：把从 j的位子开始输入0

    ```java	
    for(int i=j;i<nums.length;++i) {
    			nums[i] = 0;
    		}
    ```



Mybatis：还只是学了一部分，中途出错了，一直才摸索。明天继续。



#### 18日

牛客网：刷题40，正确15。



LeetCode算法：

- 152：乘积最大子数组

  - 解法一：每次进一位的乘剩余的数组，在进行最大值的比较

    ```java
    for(int i = 0; i < nums.length; i++)
        for(int j = i; j < num.length; j++){
            mul *= nums[j];
            max = Math.max(max, mul);
        }
    ```

  - 解法二：动态规划，将乘积的数放进数组里面，之后再挨个比较最大值。



Mybatis：明日需要把查询操作完成一边，按照狂神的方法。



#### 19日

牛客网：刷题30，正确20。



Mybatis：完成昨晚的要求，回想起了之前学习的操作，完成复习。



设计模式：复习了工厂模式。整理设计模式笔记。



明日需要完成： 算法题，狂神的设计模式，狂神的Mybatis，牛客，笔记整理，有时间就多看看狂神复习注解和反射



#### 20日

牛客网：刷题30，正确16。



LeetCode算法：

- 287：寻找重复数组   // 观察题目可以知道数组里的数为下标n+1内的数

  - 解法一：常见的集合算法，sort数组再循环都不太好。集合效率慢，sort破环原有数据。

  - 解法二：弗洛伊德的乌龟和兔子  // 快慢针  原理在以上**算法归纳**中

    可以观察到以值为索引的进入循环，遇到相同的数，会进入循环。

    ```java
    // nums = [3,1,3,4,2];
    public int findDuplicate(int[] nums) {
        // 找出两条跑道的交点
        int 乌龟 = nums[0];
        int 兔子 = nums[0];
        do {
            乌龟 = nums[乌龟];
            兔子 = nums[nums[兔子]];
        } while (乌龟 != 兔子);
        
    	// 找到循环的入口
        int p1 = nums[0];
        int p2 = 乌龟;
        while (p1 != p2) {
            p1 = nums[p1];
            p2 = nums[p2];
        }
        return p1;
    }
    ```



Mybatis：CRUD。没有去实践

​    

​    

#### 21日

牛客网：刷题30，正确13。



JavaWeb复习

Mybatis实践的问题解决



#### 22日

牛客网：刷题30，正确17。



Mybatis：看了5集，内容是复习之前学过的知识，以及记笔记。

JavaWeb：看了5集，复习内容，以及一些细的姿势点，记笔记。



完成的练习：熟练的完成了Mybatis基础的练习，每日重复练习。



明日继续，但是需要注意**算法**的完成。



#### 23日

牛客网：刷题30，正确16。



Mybatis：看了8集，复习到了注解代替配置文件

多线程和注解的课程各开了下头



睡前完成了超级简单的算法

- 344：反转字符串 ：直接头尾的交换 效率超过99.96% 内存消耗击败了92.73%



#### 24日

LeetCode算法：

- 345：反转字符串中的元音字母 aeiou难度：简单

  没有难度，就是要写挺长的代码



#### 27日

问题：项目找不到程序包和符号问题

解决：有几种方式

1. 在terminal 执行命令 mvn idea:idea  【我是只执行这个就可以了】
2. Reimport  Maven
3.  修改File Encoding 里三个改成UTF-8
4. 重启IDEA
5. 模块Rebuild



完结Mybatis，开始新的Spring目前在第5集





#### 28日

###### 问题：**错误: 找不到或无法加载主类**

解决：

![image-20200529000423037](每日总结.assets/image-20200529000423037.png)

注意：删除重启后，要重新添加maven框架，项目右键添加即可。



#### 29日

错误：org.springframework.util.xml.SimpleSaxErrorHandler.warning Ignored XML

原因：在增加spring自动装配注解的时候，自己手动修改核心配置文件，而没有黏贴官方的，导致错误。

解决：重新粘体复制解决。





### 6月

#### 1日

问题：org.apache.ibatis.binding.BindingException: Type interface xxx is not known to the MapperRegistry

解决：查看namespace 绑定































