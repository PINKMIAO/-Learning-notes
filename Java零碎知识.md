# Java零碎知识点

## 1-30

1. IDEA类里生成GetSet，右键Generate便有

2. 在整个应用程序中使用数据访问对象(DAO)使我们可以将底层数据访问逻辑与业务逻辑分离开来。
   我们构建了为每一个数据源提供 CRUD (创建、读取、更新、删除)操作的 DAO 类。 //增删改查

3. API：是(Application Programming Interface）的简称,它的具体意思是：应用程序编程接口，是一些预先定义的类。
   运用：我们做程序员的可以直接使用这些已经被打包的类来做具体的应用。
   好处：这样就节约了程序员大量的时间和精力

4. J2Sdk：是Sun公司开发的编程工具。Jcreator只起到了一个记事本的作用。
   而J2Sdk才是真正的编译和运行环境。

5. Applet：是一种特殊的Java程序。
   它本身不能单独运行，需要嵌入在一个HTML文件中，借助浏览器或Appletviewer来解释执行，
   Applet可能通过网络传输，由浏览器自动装载并执行。
   Appletviewer.exe就是用来解释执行java，能被他执行的文件没有main()方法

   java.applet是用实现运行于Internet浏览器中的Java小程序的工具类库，它仅包含一个非常有用的类：java.applet.Applet。

6. Object类中有7个方法

   * equals(Object obj); 
   * hashCode();
   * toString();
   * getClass();
   * notify(); 
   * notifayAll();
   * wait();  
   * clone(); 
   * finalize()
     其中后4个 .getClass(); .notify(); .notifayAll(); .wait();被final方法，无法被重写。

7. Condition实在java1.5中才出现的，它用来代替传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notifiy(),
   使用Condition的await()、signal()这种方式实现线程协作更加安全和高效。

   Condition是一个接口，基本方法就是await()和signal()方法。

8. constructor就是每个类中的构造器

   执行顺序： 1.主调类的静态代码块       static{ //静态代码块又称为静态初始化块 }
   			  	  2.父类的静态代码块和静态成员变量，按出现顺序初始化。
   			        3.子类的静态代码块和静态成员变量，按出现顺序初始化。
   			        4.父类的非静态代码块
   			        5.父类的构造函数
   			        6.子类的非静态代码块
   			        7.子类的构造函数

   静态变量只能在类主体中定义，不能在方法中定义。--在方法中不能定义static
   静态变量属于类所有，而不属于方法，所以交类变量。
   类方法可以调用其他类的static方法。

   static不能修饰方法中的局部变量。

9. Java类的全限定名= 包名 + 类型  例：com.edu.test.HelloWorld;

10. Java有两种对象：实例对象和Class对象。实例对象就通过Class对象来创建的。
    如果说类是对象抽象和集合的话，那么Class类就是对类的抽象和集合。

11. JVM类加载机制分为5个部分：==加载==，==链接==={验证，准备，解析}，==初始化==，使用，卸载
    JVM在判断两个class是否相同是，不仅要判断两个类名是否相等，而且判断是否有同一个类加载器实例加载的。

12. 什么是线程安全：就是线程同步的意思
    	其集合的线程安全：  

    - Vector：就比Arraylist多了个同步化机制（线程安全）Vector：在定义为存放Object，则可以存放任意类型。

    - Hashtable：就比Hashmap多了个线程安全。过时了

    - ConcurrentHashMap:是一种高效且线程安全的集合。由HashMap实现，特征相似。

    - Stack：栈，也是线程安全的，继承于Vector。

    - StringBuffer 线程安全    StringBuilder 线程不安全

    - Properties 实现了Map接口，安全

      



13. 集合中：

    - ArrayList底层是数组实现，所以允许存放重复对象。

    - TreeSet改善了HashSet的无序单一。

    - HashSet通过HashCode 和equals()方法确定单一。

      其中两对象HashCode相等，那么这两个对象可能相等也可能不相等，需要通过equals()来判断

    - ArrayList默认创建的大小为10的数组，每次扩容大小为1.5倍。

      且如果在创建的时加上空间大小，例：ArrayList list = new ArrayList(20);
      
      调用ArrayList的有参构造函数内，直接分配其大小，不扩充。所以，每次数据超过初始大小时，就会重新分配一个更大的1.5倍的连续空间。

14. Integer的范围是[-128，127]，在这个范围内比大小，相等为true，因为是同个对象数组; 超过范围false，则都是新建的对象，要用equals()来判断。
    这为==缓冲==的一段整数对象区间，目的是在不要求必须新建一个整型对象，缓存最常用的值，会更省空间，速度也更快。也就是说，是为了自动装箱时可以复用这些对象。最低值IntegerCache.low =-128是固定的，
    最大值并非固定的，由`Djava.lang.Integer.IntegerCache.high =<value> ` 来设置的，未指定则为127。
    因此可以通过这参数来修改最大值。

    byte的取值范围是[-128，127]。

15. `i = 0; i = i++;` 然后i 还是等于0。
    原因：一开始将i = 0 存放在寄存器中，然后便开始i 的自增， i 在赋值的时候取得是存放在寄存器中的i。

16. 面向对象的五大基本原则：solid

    - 单一基本原则（Single-Respossibility Principle）
    - 开放封闭原则（Open-Closed Principle）
    - 里氏替换原则（Liskov-Substituion Principle）
    - 接口隔离原则（Interface-Sergregation Principle）
    - 依赖倒置原则（Dependecy-Inversion Principle）


17. 面向对象的三大基本元素：封装、继承、多态 ; 若四大，加个抽象

18. 子类能继承父类的所有成员，即使是私有的（不管是否是final）。只是不能直接调用私有方法变量，但是可以利用反射的方式调用。

19. finally中的return语句会覆盖try-catch中的return语句。且finally的执行，不会影响try中的返回结果。

    try-catch 会给系统更大的开销。

20. - 垃圾回收机制在JVM中优先级相当相当低。
    - 垃圾回收器GC，程序开发者只能推荐JVM进行回收，但不能控制。
    - 并不是程序结束后GC，GC时间的不确定的，且GC的过程需要经过可达性分析，一个对象只有被标记两次才会被GC。 
    - 第一次标记：当失去引用链的时候。第二次标记：没有重写finalize()或对象的finalize()被执行。
    - 进入DEAD的线程，它还可以恢复，GC不会回收。

21. Java只支持单继承，实现多重继承的三种方式： 
    1. 直接实现多个接口
    2. 扩展（extends派生）一个类然后实现一个或多个接口
    3. 通过内部类去继承其他类

22. Java保留字，也是关键字 counst和goto

23. 虚函数：Java中的普通成员函数就是虚函数。加上final关键词就变成非虚函数。虚函数的存在就是为了多态。
    纯虚函数：Java抽象函数

24. final：修饰类、方法、变量，被修饰的任何不会被继承。被修饰的类称最终类，final关键词就变成非虚函数。

    final修饰的成员变量在赋值时可以有三种方式。

    - 在声明的时候直接赋值。
    - 在构造器中赋值。
    - 在初始代码块中进行赋值。

    被final修饰的基本数据类型不可修改。但是修饰引用类型时，虽然不能在指向其他对象，但是对象的内容是可以变化的。

25. JVM内存五大区域：PC寄存器(程序计数器)、堆(Heap)、本地方法栈--栈(Stack)、虚拟机栈--栈帧(Stack Frame)、方法区(Method Area)

    其中线程==共享==：堆、方法区    线程==私有==：PC寄存器、本地方法栈、虚拟机栈

26. Java只有byte、blooean是一个字节，char是两个字节，不会发生溢出。

    ```java
    char ch = 127; 
    int i = 200;
    ch += 1;
    i += ch;   得：i = 328
    ```

    byte, short, char进行计算时都会提升为int类型。
    整数类型：byte、short、int、long

27. 引用类型：String、Array    

    基本类型（原生类）：int、char、float等
    long l = 012; float f = 3.14; 缺少l和f，但由于是基本类型，所以会进行转换。其中float若是Float则会报错。

28. forward：转发页面和转发到的页面可以共享request里面的数据。
    redirect：不能共享数据。
    
29. JVM堆分为：新生区(一般是一个Eden区，两个Survivor区)，老年区(old区)
    新生区中：Eden、(from、to)-两个Survivor区  ---默认分配空键8:1:1
    JVM每次只会使用 Eden和其中一块 Survivor区域来为对象服务，所以无论什么时候，总是会有一块Survior区域是空闲的。（并不是说只固定的使用一个Survivor，而是两空间来回交换使用。详情查看书中P~127~）
    因此，新生代实际可用的内存空间为 9/10(90%)的新生代空间。

    JVM内存配置参数：

    - -Xms:最小堆容量
    
    - -Xmx:最大堆容量
    - -Xmn:年轻代大小
- -XXSurvivorRatio:年轻代中Eden区与Survivor区的大小比值
    - -XX:MaxTenuringThreshold（最大阈值）参数，能配置计数器的值来配合YGC。
    
    -X表示他是JVM运行参数，ms是memory start的简称，mx是memory max的简称。
    
    在通常情况下，服务器在运行过程中，对空间不点的扩容与回缩，会形成不必要的系统压力，所以在线上生产环境中，JVM的 Xms 和 Xmx设置成一样大小，避免在GC后调整堆大小时带来的额外压力。 

    ```
    例：-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3最小内存值和Survivor区总大小分别为？
    分析：年轻代5120m  Eden: Survivor=3，Survivor区大小1024m (Survivor区有两个，将年轻代分为5份，每个Survivor占一份)
    得出：Xms初始堆大小--即最小内存为10240m
    ```
    
30. Java继承中对构造器是不继承的，只是显式或者隐式调用。

## 31-60

31. 类之间常见的几种关系：
    - is-a(继承关系)
    - can-do(接口实现)
    - has-a(聚合关系)
    - uses-a(依赖关系)

32. 查看Java教材书P~112~正则表达式所有元字符的含义。

33. 反射破坏了代码的封装性，破坏原有的访问修饰符访问限制。

34. javac：将源程序编译成字节码  ---产生字节码文件的扩展名为class
    javac一次可同时编译数个Java源文件。
    javac.exe能指定编译结果要置于那个目录。

    java test 运行的是test.class文件

35. 使用线程wait()必须要进行异常捕获。
    调用wait或者notify方法必须采用synchronized中的对象。

    继承Thread类（重写run方法）；实现Runable接口（实现run方法）

36. 局部变量可以先声明不用必须初始化，但使用到了一定要先初始化。
    例：`String s;  int a; ` 若要输出s 或a ， 则代码编译不能通过。

37. 数组的是.length属性，String类型是.length()方法。

38. 多态的表现形式是重写。继承是多态的根源。

39. switch语句()里只能是char,int,short,long,枚举,String（java7开始支持）。
    不能是==float,double,boolean==类型。

40. 布尔型boolean可以在if判断里进行赋值操作。

41. 例： if(blooean = true){}
    boolean类型不能和任何类型进行转换，会爆出类型异常错误。例：int i = (int)true;

42. Java也是有当“+”的运算式中，有String的时候，最后的是都会是String。
    `x=20,y=5  sout(x+y+""+(x+y)+y) `   得: 25255

43. private int f;虽然是Test类的私有成员属性，但因为main方法就在Test类内，因此可以通过“==对象名==.属性名”的方式调用
    static静态成员属性==不能==使用this关键词调用
    Java程序的==入口必须==是static类型的，接口中不允许有static类型的方法。

44. WebLogic中开发消息Bean时的persistent与non-persisten的差别：
    persisten方式的MDB可以保证消息传递的可靠性
    non-persistent方式的消息将被丢弃

45. Math.cos为计算弧度的余弦值，Math.toRadians函数将角度转换为弧度

46. ArrayList的空间浪费主要体现在List列表的结尾预留一定的容量空间，
    而LinkedList的空间消费则体现在每一个元素都需要消耗相当的空间。

47. `URL u = new URL("www.123.com");`需要抛出IOException异常。
    无论网址存在否，都会返回该网址的一个连接。

48. - HashMap允许空键，空值。数据结构为数组+链表
    - TreeMap不可以空键，会报NullPointerE...异常，可以空值。

49. 计算机能处理的最小的数据项为：位<字节<字<双字

50. Java 程序内存泄漏的最直接表现是，程序抛出存控制的Exception (OutOfMemoryExpection)。

51. class是object的派生类（子类）。

52. thread.join(); 是将指定的线程加入到当前线程。
    例：在线程B 中调用了线程A 的join()方法，直到线程A执行完毕后，才会继续执行线程B。
            如果线程B 自身调用了join方法，是没有执行的。

53. String是常量 StringBuffer是变量

54. Map.containsKey方法——判断Map集合对象中是否包含指定的键名。返回值位blooean

55. 为什么常用`Map<> map = new HashMap();`  // 接口回调
    接口变量可以调用被类实现的接口方法

    如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，
    就都应该使用就接口类型进行声明。
    总结：用接口引用对象会使程序更加灵活。

56. 抽象类方法的访问权限默认是  

    - JDK1.8前 - > protected
    -  JDK1.8时 - > default

57. 关于接口方法的访问权限默认  
    - JDK1.8前 - > 必须public
    - JDK1.8时 - > 可以是public，也可以是default
    - JDK1.9时 - > 可以是private

58. 强引用：一个对象付给一个引用就是强引用，比如new一个对象，一个对象被赋值一个对象。
    软引用：用SoftReference类实现，一般不会轻易回收，只有内存不够才会回收。
    弱引用：用WeakReference类实现，一旦垃圾回收已经启动，就会回收。
    虚引用：不能单独存在，==必须==和引用队列联合使用，==主要作用是跟踪对象被回收的状态==。PhantomReference

59. 要启动线程是需要调用 对象.start()方法。
    若想把线程里的run方法当普通方法，就直接 实例.run()执行就好了。
    Thread中，run方法是个空方法，没有具体实现。

    要熟记住教材书中P~208~中，线程的声明周期图

60. ^：按位异或运算符号。

    17^5   运算规则：将两数转成二进制，然后从高位开始比较， 如果相同则为0，不相同则为1。
    			17: 0001 0001
    			  5: 0000 0101   得数为：0001 0100 转为二进制 为20
    			用权相加法，$1*2^4+0*2^3+1*2^2+0*2^1+0*2^0$
    								= $1*2^4 + 1*2^2 = 20$
    		   （其中前面多出来的0，是参与运算的类型是int类型，8个字节，凑出来看着方便）

    

     `x=5>>2 // 右移运算符     y=x>>>2 // 无符号右移运算符`
    5除于2的平方	                 >>>代表无符号 右移，高位用0填充，0001右移两位0000

    详细看高效java书中P~21~页

## 61-90

61. 想要调用构造函数，需要先初始化。
    只要没有定义任何构造函数，JVM都会为类生成一个默认构造函数。

62. ORM：对象关系映射（应该是ObjectReferenceMapping）是一种规范。三组映射关系，类与表、类中成员变量与表中字段、类的对象与表中记录。
    常用的ORM工具主要有三个 JPA、Hibernate、MyBatis（谷歌公司推出的持久层框架）
    mybatis封装了访问数据库的软件半成品

63. 源程序文件中定义多个类和接口，则编译该文件后生成多个以.class为后缀的字节码文件。

64. 异常类的层次图，教材书中P~92~。Throwable是所有异常类的父类。

65. 后缀位Stream的都是字节流，其他的都是字符流。

        节点流：FileInputStream、FileOutStream、FileReader、FileWriter、StringReader等
        处理流：DateInputStream（缓冲流）、BufferedInputStream（数据流）、InputStreamReader（转换流）
        （有Input，也有Output，只是没打上去）

66. String s = null; 此时调用s.length()方法会抛出 空指针异常。

67. System.out.println();
    System是java.lang种的一个类，out是System内的一个成员变量，这个变量是一个java.io.PrintStream类的对象。println就是一个方法。

68. ThreadLocal解决了哈希冲突的开放定址法。它会经常需要清除无用的对象，使用纯数组更加方便。
    ThreadLocal继承Object，没有实现任何接口，他并不是一个Thread，而是Thread的局部变量。

69. JSP分页代码中：先取总记录数，得到总页数，（再取所有的记录），最后显示文本的页数。

70. Math.ceil：方法中有一段注解：如果参数小于0且大于-1.0，结果为-0。  例：`Math.ceil(-0.5);   得：-0`

71. String str = new String("abc");  abc在 堆和 字符串常量区分配的。

72. 让线程暂停的方法：sleep(), synchronized()-同步阻塞。  yield是比较谦让的退出一下，让出一下CPU。
    yield()让线程回到就绪状态，yiled方法属于高风亮节的行为，这个坑位我不上了，后面跟我同级别的先上厕所。
    Thread.sleep()和Object.wait()都可以抛出InterruptedException。这个异常是不能忽略的，因为它是一个检查异常(checked exception)

73. Java, objectC, C# 是类C语言，编译型语言。 Python， Javascript 是解释型语言

74. 面向对象的语言(Java, C++)没有“过程”， 面向过程的语言(C语言)没有“对象”

75. 异常中：throws用于方法后的抛出，throw用于抛出异常。

    try检测是否有异常，有便抛出异常并执行catch语句

76. this关键词只能在构造方法中使用，且super和this必须在构造方法中的第一条语句

77. 当调用子类的构造方法创建对象时，如果子类的构造方法中没有显式地调用父类的构造方法，
    则super()方法将被自动调用，相应的，父类中必须有一个无参构造方法。
    若父类没有无参构造方法，则必须在子类中显式调用父类的有参构造方法。

78. Spring：是一系列轻量级Java EE框架的集合，包含着一个“依赖注入”模式的实现。可以使用Spring实现声明式事务。
    借助Spring与日志系统log4j实现我们自己的日志系统。

79. 采用synchronized修饰符实现的同步机制叫做互斥机制，它所获得的叫做互斥锁。
    每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有所标记便进入锁池。
    任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。

80. Struts1, Struts2？

    Struts框架基于MVC模式、可以进行文件上传、让流程结构更加清晰、需要很多action类，会增加类文件数目。

81. 接口实现所实现的方法，要服从：==两同两小一大==：

    - 方法名相同，参数类型相同。
    -  子类返回类型 <= 父类方法返回类型。
    - 子类抛出的异常 <= 父类方法抛出的异常。
    - 子类访问权限 >= 父类的访问权限。

82. 补码： 一个数的数值是11，他的模是16，那么他的补码是 16-11 = 5，即补码就是5。
    - 模没有固定的定义，简单来说模就是一个循环的周期，时钟的一个周期就是12，所以模是12。一周的模是7天，一天的模是24小时。
      模是补码的一个重要概念。
      个人定义：补码用来表示负数，使的符数可以在计算机中运算。

83. 4位二进制1111的模为10000，也就是           二进制1111 + 1 = 10000。以此类推。
    那么，想得到一个数的二进制模可以这么求：模 = 数1二进制 + 数1按位取反 + 1
    则这个数的补码： 补码 = 模 - 数二进制
                   代入模： 补码 = (数二进制 + 数按位取反 + 1) - 数二进制
                                   补码 = 数按位取反 + 1

84. 

85. 静态变量是共享的，在加载类时就分配空间了。

86. 异常处理能有多个语句块的是catch，且捕获到的只输出一个。

87. instanceof 可以判断一个对象是否为一个类的实例、一个实现指定接口的类的实例、一个子类的实例。

88. Serializable是不会序列化static变量和transient修饰的变量。
    序列化的是对象，不是类，类变量不会被序列化。

89. Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。

90. Synchronized与volatile的区别：
    - volatile是线程同步的轻量级实现，所以性能肯定比Synchronized要比好。
    - volatile只能修改变量，而Synchronized可以修饰方法，以及代码块。
    - 多线程访问volatile不会发生阻塞，而Synchronized会出现阻塞。
    - volatile能保证数据的可见性，但不能保证原子性。
    - 而Synchronized可以保证原子性，也可以间接保证可见性，因为私有内存和共有内存中的数据同步。
    - v解决变量在多线程之间可见性，s解决的多线程之间资源同步问题。


## 91-120

91. volatile只提供了内存可见性，而没有提供原子性。所以说用这个关键字做高并发的安全机制的话是不可靠的。
    用法：最好是那种只有一个线程修改变量，多个线程读取该变量的地方。也就是对内存可见性要求高的，而对原子性要求低的地方。

62. 默认初始化：在类种的成员变量会有默认值，但是在方法中的成员变量参与运算前是必须要初始化的。

63. 原子性：一个操作或多个操作要么全部执行完成且执行过程不被中断，要么就不执行。

64. 数组定义后，看数组类型赋默认值。
    - int:0、short:0、byte:0;
    - boolean:false;  float、double:0.0; 
    - 对象类型数组:null。
    -  char:'\u0000'

95.包装类：Java是面向对象语言，但基本类型不是。所以实际使用时存在很多不便，
	 解决问题，在设计类时为每个基本类型都涉及了对应的进行代表。

​	 包装类的‘==’运算，在不遇到算数运算的情况下不会自动装箱
​     包装类的equals()方法不处理数据类型

96. 线程局部存储TLS(Thread Local Storage)：解决==多线程中的对同一变量的访问冲突的一种技术==。
    java.lang.ThreadLocal是TSL技术的一种实现。

97. Map接口和Collection接口是同一等级的。

98. destroy()在销毁阶段执行，释放Servlet占用的资源
    方法只执行一次，即在服务器停止且卸载Servlet时执行该方法。

99. 创建Servlet的实例是由Servlet容器完成的，且创建Servlet实例是在初始化方法init()之前。

100. `a += b; `此语句会将被赋值的变量自动强制转化为相应的类型（自动装箱）。

101. Java中实际上提供了java.util.Stack来实现栈结构,但官方目前已不推荐使用,
     
     而是使用java.util.Deque双端队列来实现队列与栈的各种需求。
          子类有java.util.LinkedList和java.util.ArrayDeque。
          
     例:  `Deque<Integer> ans = new ArrayDeque<>(); `// 循环数组，非线程安全，不允许放null
                 `ans.addLast();.removeFirst();`
          
     
102. `100 % 3.0  得 1.0;`

103. 类种的成员变量，存放在 堆区。

     方法中的局部变量，存放在 栈区。

104. 中间件 并不能提高内核的效率，一般只是负责网络信息的分发处理。
     要提高内核效率，还是需要在内核中进行修改，与中间件无关。

105. 运行时常量池 

     - JDK1.8前，池放在 方法区中。
     - 1.8后，元空间取代了方法区，池也被放在里面。

     主要存放：class文件元信息描述，编译后的代码，引用类型数据，类文件常量池。

106. `"java" + "and" + "python" == "javaandpython";`
     因为字符串 字面量 拼接操作实在 JVM 编译期间就执行了，
     也就是说 JVM 编译时，就把那三个字面量进行”+“操作得到常量，
     再将这常量放入到字符串池中。也就是相同。

107. CMS的GC过程有6个阶段（4个并发，2个暂停其他应用程序）
     2个没用用户参与的阶段， 初始标记 和重新标记 且回应发STW。

     1、初次标记  2、并发标记  3、并发可中断预处理  4、最终重新标记  5、并发清理  6、并发重置

108. 三目运算符： 遇到可以转换位数字的类型，会做自动类型提升 

     例：

     ```java
     Object oj = (ture) ? new Integer(2) : new Double(1.0);
     得数为：2.0;
     int -> long -> float
     ```

109. Iterator 迭代器，支持从源集合中安全地删除对象，只需到在Iterator上调用remove()即可。

110. Java的基本编程单位是类，基本存储单元是变量。

111. while()里的参数必须是boolean值，while(10) --不可以，因为没有C语言中大于0的int会被认为是true，Java没有这个机制。

112. 函数式接口 --接口里只定义一个抽象方法的接口。

113. `(变量) -> {代码块} `Lambda表达式， 即匿名函数。
       参数             主体
      i -> i % 2 == 0; 如果代码块只有一个表达式，大括号可以省略。

114. 字节流和字符流每次读入的字节数是不确定的，可能相等也可能不相等。且，两者都有缓冲流。

115. 在给二维数组遍历时，我们可以使用for each 来获取每层的数组。 例：`for(int[] num : nums){}` --num数组

116. 类是单继承，但是接口可以是多继承。例：`Interfere1 extends Interface2,Interface3...`

117. 引用数据类型是引用传递（call by reference），基本数据类型是值传递（call by value）
     值传递比可以改变原变量的内容和地址。 引用传递不可以改变原变量的地址，但可以改变原变量的内容。

118. 启动线程的三种方法：1、继承Thread 2、实现Runnable 3、通过线程池Executors 或 Lambda

     ```java
     1.new Thread().start();
     2.new Thread(new MyRun).start();  ---MyRun 是实现了Runnable的类
     3.new Thread(()->{
           System.out.println("Hello, Lambda!");
       }).start();
     ```

119. 线程状态：`Thread t = new Thread();  t.getState();`获得当前线程状态。

120. javac 文件名.java，进行编译。反汇编：javap -c 文件名, 可查看底层都调用了哪些方法。

## 121-150

121. - SYN: (Synchronize Sequence Numbers)用作建立连接时的同步信号;
     - ACK: (Acknowledgement)用于对收到的数据进行确认，所确认的数据由 确认序列号 表示。
     -  FIN: (Finish)表示后面没有数据需要发送，通常意味着建立的连接需要关闭了。

     三次握手: 

     1. 客户端发出一个数据包，并将SYN设置为1，表示希望建立连接。这个数据包中的系列号假设为x。
     2. 服务端接收到了客户端发来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都设置为1。
     3. 客户端收到了服务端的响应后需要进行确认，确认包中的ACK设置为1，并将确认序列号设置为y+1，表示收到了来自B的SYN。

     **为什么需要三次握手?** 

     两个主要目的: 

     - 信息对等和防止超时。
     
- 信息对等：双方需要确定4类信息，才能建立连接。
     
                         |        | 客户端     |            |            |            | 服务端     |            |            |            |
                  | ------ | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
             |        | 自发报能力 | 自收报能力 | 对发报能力 | 对收报能力 | 自发报能力 | 自收报能力 | 对发报能力 | 对收报能力 |
             | 第一次 | N          | N          | N          | N          | N          | Y          | Y          | N          |
             | 第二次 | Y          | Y          | Y          | Y          | N          | Y          | Y          | N          |
             | 第三次 | Y          | Y          | Y          | Y          | Y          | Y          | Y          | Y          |
          
          
          
          也就是确认自己能不能发出去和对方能不能收到自己的信息

​		防止超时：防止超时导致的脏连接。

		TTL网络报文的生存时间往往都会朝贡国TCP请求超时时间。
		如果两次握手就建立连接的话，传输数据并释放连接后，第一次超时的连接请求才达到服务端，
		这样的服务端会以为客户端要创建新连接的请求，然后同意创建新连接。但客户端状态不是SYN_SENT，所以
		直接丢弃了B的确认数据，最后只是服务端单方面创建连接完毕。
122. 断开连接的四次挥手：

        1. 客户端A想要关闭连接，传递FIN信号给服务端B。 
        2. B应答ACK，告诉A可以断开，但是需要等待B处理完数据，再主动给A发送FIN信号。
        3. A接收到B发来的AKF，这时A处于半关闭状态，无法再发送新的数据。等B做好连接关闭前的准备工作后，发送FIN给A，然后也进入半关闭状态。
        4. A收到后，发送针对B机器FIN的ACK后，进图TIME_WAIT转台，经过2MSL后，没有收到B传来的报文，则确定B已经收到A最后发的ACK指令，此时TCP连接正式释放。

98. 两数进行二元操作是，会有以下操作：

    - 如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。
    - 否则，如果其中一个操作数是float类型，另一个将会转换为float类型。
    - 否则，如果其中一个操作数是long类型，另一个会转换为long类型。
    - 否则，两个操作数都转换为int类型。

    例如：` long a = 42l;  float b = 42.0f;    a == b; `   得true; 因为a 将转换为float类型。

99. - 静态内部类才可以声明静态方法
    - 静态方法不可以使用非静态变量
    - 抽象方法不可以有函数体

125. 持久层：就是将数据持久化，怎么持久化，将数据存进数据库。

126. 在`A a = new B();`创建派生类的过程中首先创建基类对象，然后才能创建派生类

     - 创建基类即默认调用构造方法。

     - 若派生类中有重写基类的方法，且在基类构造方法中被调用，那么将调用派生类重写的方法。

       由于此时的派生类还未构造，所以方法中的参数都是空的。

127. `getClass()`返回的当前运行的类，`getName()`返回的是：包名+类名

128. `replaceAll('', )` 方法的第一个参数是正则表达式。在正则表达式中`‘.’`代表任何字符。

     所以`replaceAll('.', '/')`意思是把所有的换成`'/'`。

129. 创建对象的方法：

     1. 通过我们最常用的new方法
     2. 运用反射手段，调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
     3. 调用对象的clone()方法
     4. 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。

130. 









